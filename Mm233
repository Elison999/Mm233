local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
Name = "Bridge hub - MM2 - By darker9899",
Icon = 0,
LoadingTitle = "Loading...",
LoadingSubtitle = "by darker9899",
ShowText = "Rayfield",
Theme = "Default",
ToggleUIKeybind = "K",
DisableRayfieldPrompts = false,
DisableBuildWarnings = false,
ConfigurationSaving = {
Enabled = true,
FolderName = nil,
FileName = "Big Hub"
},
Discord = {
Enabled = false,
Invite = "noinvitelink",
RememberJoins = true
},
KeySystem = false,
KeySettings = {
Title = "Untitled",
Subtitle = "Key System",
Note = "No method of obtaining the key is provided",
FileName = "Key",
SaveKey = true,
GrabKeyFromSite = false,
Key = {"JKB"}
}
})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local Lighting = game:GetService("Lighting")
local Terrain = Workspace:FindFirstChildOfClass("Terrain")
local LocalPlayer = Players.LocalPlayer

local TabPremium = Window:CreateTab("Premium", 4483362458)

-- ✅ ADICIONAR ESTE CÓDIGO NA ABA ANTILAG (antes do final)

local removeTexturesEnabled = false

-- Função para remover todas as texturas
local function removeAllTextures()
    -- Remove texturas de todas as partes do workspace
    for _, obj in pairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            obj.Material = Enum.Material.SmoothPlastic
            obj.Color = Color3.fromRGB(100, 100, 100) -- Cor cinza neutra
        elseif obj:IsA("Decal") or obj:IsA("Texture") then
            obj.Transparency = 1
        elseif obj:IsA("SurfaceGui") then
            obj.Enabled = false
        elseif obj:IsA("BillboardGui") then
            obj.Enabled = false
        elseif obj:IsA("ImageLabel") or obj:IsA("ImageButton") then
            obj.Image = ""
            obj.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        end
    end
    
    -- Remove texturas dos players
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            for _, part in pairs(player.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.Material = Enum.Material.SmoothPlastic
                    if part.Name == "Head" then
                        part.Color = Color3.fromRGB(255, 220, 177) -- Cor de pele
                    else
                        part.Color = Color3.fromRGB(100, 100, 100)
                    end
                elseif part:IsA("Decal") or part:IsA("Texture") then
                    part.Transparency = 1
                elseif part:IsA("Accessory") or part:IsA("Hat") then
                    part:Destroy()
                end
            end
        end
    end
    
    -- Remove/modifica elementos do Lighting
    for _, effect in pairs(Lighting:GetChildren()) do
        if effect:IsA("Atmosphere") then
            effect:Destroy()
        elseif effect:IsA("Sky") then
            effect:Destroy()
        elseif effect:IsA("BloomEffect") then
            effect.Enabled = false
        elseif effect:IsA("BlurEffect") then
            effect.Enabled = false
        elseif effect:IsA("ColorCorrectionEffect") then
            effect.Enabled = false
        elseif effect:IsA("DepthOfFieldEffect") then
            effect.Enabled = false
        elseif effect:IsA("SunRaysEffect") then
            effect.Enabled = false
        end
    end
    
    -- Configurações básicas do Lighting
    Lighting.Brightness = 1
    Lighting.Ambient = Color3.fromRGB(100, 100, 100)
    Lighting.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
    Lighting.ColorShift_Top = Color3.fromRGB(0, 0, 0)
    Lighting.FogColor = Color3.fromRGB(100, 100, 100)
    Lighting.FogEnd = 1000000
    Lighting.FogStart = 0
end

-- Toggle para Remove All Textures
TabPremium:CreateToggle({
    Name = "Remove All Textures (Ultra Performance)",
    CurrentValue = false,
    Callback = function(value)
        removeTexturesEnabled = value
        if value then
            removeAllTextures()
        end
    end
})

-- Loop que atualiza as texturas a cada 1 segundo
task.spawn(function()
    while true do
        if removeTexturesEnabled then
            pcall(removeAllTextures) -- pcall para evitar erros
        end
        task.wait(1) -- Atualiza a cada 1 segundo
    end
end)

local TabESP = Window:CreateTab("Esp", 4483362458)
local ESP_Ativo = false

local function RemoverTodosHighlights()
for _, player in pairs(Players:GetPlayers()) do
if player.Character and player.Character:FindFirstChild("OutlineESP") then
player.Character.OutlineESP:Destroy()
end
end
end

local function UpdateHighlight(player)
if player.Character then
local highlight = player.Character:FindFirstChild("OutlineESP")
if not highlight then
highlight = Instance.new("Highlight")
highlight.Name = "OutlineESP"
highlight.Adornee = player.Character
highlight.FillTransparency = 1
highlight.OutlineTransparency = 0
highlight.Parent = player.Character
end

local tool = player.Character:FindFirstChildOfClass("Tool") or (player:FindFirstChild("Backpack") and player.Backpack:FindFirstChildOfClass("Tool"))
if tool then
local name = tool.Name:lower()
if name:find("gun") then
highlight.OutlineColor = Color3.fromRGB(0, 170, 255)
elseif name:find("knife") then
highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
else
highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
end
else
highlight.OutlineColor = Color3.fromRGB(0, 255, 0)
end
end
end

TabESP:CreateToggle({
Name = "Outline ESP",
CurrentValue = false,
Flag = "ToggleESP",
Callback = function(Value)
ESP_Ativo = Value
if not ESP_Ativo then RemoverTodosHighlights() end
end,
})

task.spawn(function()
while true do
if ESP_Ativo then
for _, player in pairs(Players:GetPlayers()) do
if player ~= LocalPlayer then
UpdateHighlight(player)
end
end
end
task.wait(0.1)
end
end)

Players.PlayerAdded:Connect(function(player)
player.CharacterAdded:Connect(function()
task.wait(1)
if ESP_Ativo then UpdateHighlight(player) end
end)
end)

for _, player in pairs(Players:GetPlayers()) do
if player ~= LocalPlayer then
player.CharacterAdded:Connect(function()
task.wait(1)
if ESP_Ativo then UpdateHighlight(player) end
end)
end
end

local TabMovement = Window:CreateTab("Movement", 4483362458)
local GlitchSpeed = 33  -- Valor padrão
local NormalSpeed = 16
local ToggleEnabled = false
local IsJumping = false

local function SetSpeed(speed)
local char = LocalPlayer.Character
if char and char:FindFirstChildOfClass("Humanoid") then
char:FindFirstChildOfClass("Humanoid").WalkSpeed = speed
end
end

local function SetupHumanoid(humanoid)
if not humanoid then return end
humanoid.StateChanged:Connect(function(_, newState)
if not ToggleEnabled then return end
if newState == Enum.HumanoidStateType.Jumping or newState == Enum.HumanoidStateType.Freefall then
IsJumping = true
elseif newState == Enum.HumanoidStateType.Landed or newState == Enum.HumanoidStateType.Running then
IsJumping = false
SetSpeed(NormalSpeed)
end
end)
end

LocalPlayer.CharacterAdded:Connect(function(char)
local humanoid = char:WaitForChild("Humanoid", 5)
SetupHumanoid(humanoid)
SetSpeed(NormalSpeed)
end)

if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
SetupHumanoid(LocalPlayer.Character:FindFirstChild("Humanoid"))
SetSpeed(NormalSpeed)
end

RunService.Heartbeat:Connect(function()
if not ToggleEnabled then return end
local char = LocalPlayer.Character
if char and char:FindFirstChildOfClass("Humanoid") and IsJumping then
local moving = char.Humanoid.MoveDirection.Magnitude > 0
if moving then
SetSpeed(GlitchSpeed)
end
end
end)

-- ✅ TOGGLE DO SPEED GLITCH
TabMovement:CreateToggle({
Name = "Glitch Speed (Mobile)",
CurrentValue = false,
Flag = "GlitchSpeedToggle",
Callback = function(Value)
ToggleEnabled = Value
SetSpeed(NormalSpeed)
end,
})

-- ✅ NOVO SLIDER PARA CONTROLAR A VELOCIDADE
TabMovement:CreateSlider({
Name = "Speed Glitch Velocity",
Range = {16, 200},
Increment = 1,
Suffix = " Speed",
CurrentValue = 33,
Flag = "SpeedGlitchSlider",
Callback = function(Value)
GlitchSpeed = Value
end,
})

-- ✅ SLIDER PARA VELOCIDADE NORMAL TAMBÉM
TabMovement:CreateSlider({
Name = "Normal Walk Speed",
Range = {1, 50},
Increment = 1,
Suffix = " Speed",
CurrentValue = 16,
Flag = "NormalSpeedSlider",
Callback = function(Value)
NormalSpeed = Value
-- Atualiza a velocidade atual se não estiver no speed glitch
if not IsJumping and LocalPlayer.Character then
SetSpeed(NormalSpeed)
end
end,
})

local TabInnocents = Window:CreateTab("Innocents", 4483362458)
-- Variáveis
local antiMurderEnabled = false
local detectionRadius = 20
local shiftLockLoop = nil
local player = game.Players.LocalPlayer
local runService = game:GetService("RunService")
local autoRunEnabled = false
local runDistance = 25
local isRunning = false

-- Função para verificar se um jogador é o assassino (Innocents)
local function isMurdererInnocent(player)
    if not player or not player.Character then return false end
    
    -- Verifica se tem faca no character
    local knife = player.Character:FindFirstChild("Knife")
    if knife then return true end
    
    -- Verifica se tem faca no backpack
    if player.Backpack and player.Backpack:FindFirstChild("Knife") then
        return true
    end
    
    return false
end

-- Função para encontrar o assassino mais próximo
local function getNearestMurderer()
    local myCharacter = LocalPlayer.Character
    if not myCharacter or not myCharacter:FindFirstChild("HumanoidRootPart") then
        return nil, math.huge
    end
    
    local myPosition = myCharacter.HumanoidRootPart.Position
    local nearestMurderer = nil
    local nearestDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and isMurdererInnocent(player) and player.Character then
            local murdererRoot = player.Character:FindFirstChild("HumanoidRootPart")
            if murdererRoot then
                local distance = (murdererRoot.Position - myPosition).Magnitude
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestMurderer = player
                end
            end
        end
    end
    
    return nearestMurderer, nearestDistance
end

-- Função para fugir do assassino
local function runFromMurderer(murdererCharacter)
    local myCharacter = LocalPlayer.Character
    if not myCharacter or not myCharacter:FindFirstChild("HumanoidRootPart") then return end
    
    local myRoot = myCharacter.HumanoidRootPart
    local murdererRoot = murdererCharacter:FindFirstChild("HumanoidRootPart")
    if not murdererRoot then return end
    
    local humanoid = myCharacter:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    -- Calcula direção oposta ao assassino
    local directionAway = (myRoot.Position - murdererRoot.Position).Unit
    local runPosition = myRoot.Position + (directionAway * 50)
    
    -- Move o personagem para longe
    humanoid:MoveTo(runPosition)
    isRunning = true
    
    -- Para de correr após um tempo
    task.spawn(function()
        task.wait(0.001)
        isRunning = false
    end)
end

-- Toggle para Auto Run from Murder
TabInnocents:CreateToggle({
    Name = "Auto Run from Murder (Dist 25)",
    CurrentValue = false,
    Flag = "AutoRunFromMurder",
    Callback = function(Value)
        autoRunEnabled = Value
    end,
})

-- Loop principal para verificar assassinos próximos
task.spawn(function()
    while true do
        if autoRunEnabled then
            local murderer, distance = getNearestMurderer()
            
            if murderer and distance <= runDistance and not isRunning then
                -- Verifica se não sou o sheriff (para não fugir desnecessariamente)
                local myCharacter = LocalPlayer.Character
                local hasGun = (myCharacter and myCharacter:FindFirstChild("Gun")) or 
                              (LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChild("Gun"))
                
                if not hasGun then -- Só foge se não for o sheriff
                    runFromMurderer(murderer.Character)
                end
            end
        end
        
        task.wait(0.00001) -- Verifica a cada 0.5 segundos
    end
end)

-- Toggle principal
TabInnocents:CreateToggle({
    Name = "Anti-Murder",
    CurrentValue = false,
    Flag = "AntiMurderToggle",
    Callback = function(Value)
        antiMurderEnabled = Value
        
        if antiMurderEnabled then
            -- Inicia o loop de detecção
            shiftLockLoop = runService.Heartbeat:Connect(function()
                if detectMurderNearby() then
                    toggleShiftLock(true)
                else
                    toggleShiftLock(false)
                end
            end)
            
            print("Anti-Murder ativado! Detector de distância: " .. detectionRadius)
        else
            -- Para o loop e desativa o shift lock
            if shiftLockLoop then
                shiftLockLoop:Disconnect()
                shiftLockLoop = nil
            end
            toggleShiftLock(false)
            
            print("Anti-Murder desativado!")
        end
    end,
})

-- Função para ativar/desativar ShiftLock
local function toggleShiftLock(enable)
    if enable then
        player.DevEnableMouseLock = true
        game:GetService("UserInputService").MouseBehavior = Enum.MouseBehavior.LockCenter
    else
        player.DevEnableMouseLock = false
        game:GetService("UserInputService").MouseBehavior = Enum.MouseBehavior.Default
    end
end

-- Função para detectar murder próximo
local function detectMurderNearby()
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local playerPosition = player.Character.HumanoidRootPart.Position
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            -- Verifica se o jogador tem uma knife (é o murder)
            local backpack = otherPlayer.Backpack
            local character = otherPlayer.Character
            
            local hasKnife = (backpack and backpack:FindFirstChild("Knife")) or 
                           (character and character:FindFirstChild("Knife"))
            
            if hasKnife then
                local distance = (otherPlayer.Character.HumanoidRootPart.Position - playerPosition).Magnitude
                if distance <= detectionRadius then
                    return true
                end
            end
        end
    end
    
    return false
end

local TabSheriff = Window:CreateTab("Sheriff", 4483362458)
local autoShootEnabled = true
local autoShootV2Enabled = false
local shootMode = "Curve"
local prioritizePing = true
local antiflingEnabled = false

TabSheriff:CreateToggle({
Name = "Auto Shoot",
CurrentValue = true,
Flag = "AutoShootToggle",
Callback = function(Value)
autoShootEnabled = Value
end,
})

TabSheriff:CreateToggle({
Name = "Auto Shoot V2 (Smart Vision)",
CurrentValue = false,
Flag = "AutoShootV2Toggle",
Callback = function(Value)
autoShootV2Enabled = Value
end,
})

TabSheriff:CreateDropdown({
Name = "Choose Shoot Mode",
Options = {"Curve", "Static", "Instantly", "Prever Murder"},
CurrentOption = "Curve",
Flag = "ShootModeDropdown",
Callback = function(Option)
shootMode = Option
end,
})

TabSheriff:CreateToggle({
Name = "Prioritize Ping",
CurrentValue = true,
Flag = "PrioritizePingToggle",
Callback = function(Value)
prioritizePing = Value
end,
})

TabSheriff:CreateToggle({
Name = "Anti Fling (Pass through Players)",
CurrentValue = false,
Flag = "AntiFlingToggle",
Callback = function(Value)
antiflingEnabled = Value
if antiflingEnabled and LocalPlayer.Character then
for _, otherPlayer in pairs(Players:GetPlayers()) do
if otherPlayer ~= LocalPlayer and otherPlayer.Character then
for _, myPart in pairs(LocalPlayer.Character:GetChildren()) do
if myPart:IsA("BasePart") then
for _, otherPart in pairs(otherPlayer.Character:GetChildren()) do
if otherPart:IsA("BasePart") then
myPart:SetNetworkOwner(nil)
myPart.CanCollide = true
otherPart.CanCollide = true
pcall(function()
myPart:GetPropertyChangedSignal("CanCollide"):Wait()
end)
game:GetService("PhysicsService"):SetPartCollisionGroup(myPart, "NoCollidePlayers")
game:GetService("PhysicsService"):SetPartCollisionGroup(otherPart, "NoCollidePlayers")
end
end
end
end
end
end
else
if LocalPlayer.Character then
for _, part in pairs(LocalPlayer.Character:GetChildren()) do
if part:IsA("BasePart") then
part.CanCollide = true
game:GetService("PhysicsService"):SetPartCollisionGroup(part, "Default")
end
end
end
end
end,
})

-- ✅ BOTÃO NA ABA: SHOOT MURDER
TabSheriff:CreateButton({
Name = "🎯 Shoot Murder (Teleport)",
Callback = function()
pcall(function()
-- Verifica se está vivo e tem arma
if not isPlayerAlive(LocalPlayer) then return end
if not hasGun() then return end

local char = LocalPlayer.Character
local myRoot = char:FindFirstChild("HumanoidRootPart")
if not myRoot then return end

-- Salva posição original
local originalPosition = myRoot.CFrame

-- Encontra o murder
local targetMurderer = findNearestMurderer()
if not targetMurderer then 
Rayfield:Notify({
Title = "Murder não encontrado!",
Content = "Nenhum murder foi encontrado no servidor.",
Duration = 3
})
return 
end

local murdererRoot = targetMurderer.Character:FindFirstChild("HumanoidRootPart")
if not murdererRoot then return end

-- Equipa a arma
local backpack = LocalPlayer:FindFirstChild("Backpack")
local gun = backpack and backpack:FindFirstChild("Gun") or char and char:FindFirstChild("Gun")
if not gun then return end

local humanoid = char:FindFirstChildOfClass("Humanoid")
if not humanoid then return end

humanoid:EquipTool(gun)
task.wait(0.1)

-- Calcula posição atrás do murder
local murdererLookDirection = murdererRoot.CFrame.LookVector
local behindPosition = murdererRoot.Position - (murdererLookDirection * 5)
local teleportCFrame = CFrame.new(behindPosition, murdererRoot.Position)

-- Teleporta atrás do murder
myRoot.CFrame = teleportCFrame
task.wait(0.1)

-- Verifica se ainda está vivo antes de atirar
if not isPlayerAlive(LocalPlayer) then 
myRoot.CFrame = originalPosition
return 
end

-- Atira no murder
local murdererPos = murdererRoot.Position
local murdererVel = murdererRoot.Velocity
local predicted = murdererPos

if shootMode == "Curve" then
predicted = murdererPos + murdererVel * getPingTime()
elseif shootMode == "Static" then
predicted = murdererPos
elseif shootMode == "Prever Murder" then
local predictedPos = predictMurdererPosition(targetMurderer)
if predictedPos then predicted = predictedPos end
elseif shootMode == "Instantly" then
predicted = murdererPos
end

-- Executa o tiro
pcall(function()
if isPlayerAlive(LocalPlayer) then
local gunRemote = workspace:WaitForChild(LocalPlayer.Name):WaitForChild("Gun")        
:WaitForChild("KnifeLocal"):WaitForChild("CreateBeam"):WaitForChild("RemoteFunction")        
gunRemote:InvokeServer(1, predicted, "AH2")
end
end)

-- Aguarda um pouco e volta para posição original
task.wait(0.2)
if isPlayerAlive(LocalPlayer) then
myRoot.CFrame = originalPosition
end

-- Notificação de sucesso
Rayfield:Notify({
Title = "Shot Executed!",
Content = "Teleportou, atirou no murder e voltou!",
Duration = 2
})
end)
end,
})

-- Função para verificar se o jogador está vivo e tem character válido
local function isPlayerAlive(player)
if not player then return false end
if not player.Character then return false end
local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
if not humanoid then return false end
if humanoid.Health <= 0 then return false end
if not player.Character:FindFirstChild("HumanoidRootPart") then return false end
return true
end

-- Função para verificar se um jogador é assassino (Sheriff)
local function isMurdererSheriff(player)
if not isPlayerAlive(player) then return false end
local hasKnife = player.Character:FindFirstChild("Knife") or (player.Backpack and player.Backpack:FindFirstChild("Knife"))
return hasKnife ~= nil
end

-- Função para encontrar o murder mais próximo
local function findNearestMurderer()
local myCharacter = LocalPlayer.Character
if not myCharacter or not myCharacter:FindFirstChild("HumanoidRootPart") then
return nil
end

local myPosition = myCharacter.HumanoidRootPart.Position
local nearestMurderer = nil
local nearestDistance = math.huge

for _, player in pairs(Players:GetPlayers()) do
if player ~= LocalPlayer and isMurdererSheriff(player) and player.Character then
local murdererRoot = player.Character:FindFirstChild("HumanoidRootPart")
if murdererRoot then
local distance = (murdererRoot.Position - myPosition).Magnitude
if distance < nearestDistance then
nearestDistance = distance
nearestMurderer = player
end
end
end
end

return nearestMurderer
end

-- Função para prever posição do murder
local function predictMurdererPosition(murderer)
if not murderer or not murderer.Character then return nil end
local root = murderer.Character:FindFirstChild("HumanoidRootPart")
if not root then return nil end

local currentPos = root.Position
local velocity = root.Velocity
local humanoid = murderer.Character:FindFirstChildOfClass("Humanoid")
if not humanoid then return currentPos end

local myPos = LocalPlayer.Character.HumanoidRootPart.Position
local distance = (currentPos - myPos).Magnitude
local predictionTime = distance / 1000 + getPingTime()

local predictedPos = currentPos + (velocity * predictionTime)

if velocity.Magnitude > 2 then
local moveDirection = velocity.Unit
predictedPos = predictedPos + (moveDirection * 5)
end

local state = humanoid:GetState()
if state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall then
local head = murderer.Character:FindFirstChild("Head")
if head then
predictedPos = head.Position + Vector3.new(0, 2, 0)
end
end

return predictedPos
end

-- Função para verificar se o murder está no chão
local function isMurdererOnGround(murdererCharacter)
if not murdererCharacter or not murdererCharacter:FindFirstChild("HumanoidRootPart") then return false end
local humanoid = murdererCharacter:FindFirstChildOfClass("Humanoid")
if not humanoid then return false end
local state = humanoid:GetState()
return state ~= Enum.HumanoidStateType.Jumping and 
       state ~= Enum.HumanoidStateType.Freefall and
       state ~= Enum.HumanoidStateType.Flying
end

-- Função para verificar se o murder está pulando
local function isMurdererJumping(murdererCharacter)
if not murdererCharacter or not murdererCharacter:FindFirstChild("HumanoidRootPart") then return false end
local humanoid = murdererCharacter:FindFirstChildOfClass("Humanoid")
if not humanoid then return false end
local state = humanoid:GetState()
return state == Enum.HumanoidStateType.Jumping or state == Enum.HumanoidStateType.Freefall
end

-- Função para verificar se o assassino está visível e na direção certa
local function isMurdererVisible(murdererCharacter)
if not isPlayerAlive(LocalPlayer) then return false end
if not murdererCharacter or not murdererCharacter:FindFirstChild("HumanoidRootPart") then return false end

local myCharacter = LocalPlayer.Character
local myRoot = myCharacter.HumanoidRootPart
local murdererRoot = murdererCharacter.HumanoidRootPart

local distance = (murdererRoot.Position - myRoot.Position).Magnitude
if distance > 150 then return false end

local directionToMurderer = (murdererRoot.Position - myRoot.Position).Unit
local myLookDirection = myRoot.CFrame.LookVector

local dotProduct = myLookDirection:Dot(directionToMurderer)
local isInGeneralDirection = dotProduct > -0.7

local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
raycastParams.FilterDescendantsInstances = {myCharacter, murdererCharacter}

local raycastResult = Workspace:Raycast(myRoot.Position, murdererRoot.Position - myRoot.Position, raycastParams)

local isVisible = not raycastResult or (raycastResult.Distance > (murdererRoot.Position - myRoot.Position).Magnitude * 0.9)

return isInGeneralDirection and isVisible
end

-- Shoot button GUI (flutuante)
local gui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
gui.Name = "ShootGui"
gui.ResetOnSpawn = false

local button = Instance.new("TextButton", gui)
button.Size = UDim2.new(0, 100, 0, 100)
button.Position = UDim2.new(0.5, -60, 0.8, 0)
button.BackgroundColor3 = Color3.fromRGB(180, 40, 40)
button.TextColor3 = Color3.new(1, 1, 1)
button.Font = Enum.Font.SourceSansBold
button.TextSize = 14
button.Text = "SHOOT"

-- Shoot Murder Button (flutuante)
local shootMurderGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
shootMurderGui.Name = "ShootMurderGui"
shootMurderGui.ResetOnSpawn = false

local shootMurderButton = Instance.new("TextButton", shootMurderGui)
shootMurderButton.Size = UDim2.new(0, 120, 0, 50)
shootMurderButton.Position = UDim2.new(0.5, -60, 0.7, 0)
shootMurderButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
shootMurderButton.TextColor3 = Color3.new(1, 1, 1)
shootMurderButton.Font = Enum.Font.SourceSansBold
shootMurderButton.TextSize = 12
shootMurderButton.Text = "SHOOT MURDER"

-- Drag logic for normal button
local dragging, dragStart, startPos, dragInput
button.InputBegan:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
dragging = true
dragStart = input.Position
startPos = button.Position
input.Changed:Connect(function()
if input.UserInputState == Enum.UserInputState.End then
dragging = false
end
end)
end
end)

button.InputChanged:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
dragInput = input
end
end)

UserInputService.InputChanged:Connect(function(input)
if input == dragInput and dragging then
local delta = input.Position - dragStart
button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end
end)

-- Drag logic for shoot murder button
local dragging2, dragStart2, startPos2, dragInput2
shootMurderButton.InputBegan:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
dragging2 = true
dragStart2 = input.Position
startPos2 = shootMurderButton.Position
input.Changed:Connect(function()
if input.UserInputState == Enum.UserInputState.End then
dragging2 = false
end
end)
end
end)

shootMurderButton.InputChanged:Connect(function(input)
if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
dragInput2 = input
end
end)

UserInputService.InputChanged:Connect(function(input)
if input == dragInput2 and dragging2 then
local delta = input.Position - dragStart2
shootMurderButton.Position = UDim2.new(startPos2.X.Scale, startPos2.X.Offset + delta.X, startPos2.Y.Scale, startPos2.Y.Offset + delta.Y)
end
end)

local function getPingTime()
if not prioritizePing then return 0 end
return 0.125
end

-- Função para verificar se tem arma
local function hasGun()
if not isPlayerAlive(LocalPlayer) then return false end
local char = LocalPlayer.Character
local backpack = LocalPlayer:FindFirstChild("Backpack")
local gun = backpack and backpack:FindFirstChild("Gun") or char and char:FindFirstChild("Gun")
return gun ~= nil
end

local function shoot()
if not isPlayerAlive(LocalPlayer) then return end
if not hasGun() then return end

TweenService:Create(button, TweenInfo.new(0.1), {Size = UDim2.new(0, 100, 0, 90)}):Play()
task.wait(0.1)
TweenService:Create(button, TweenInfo.new(0.1), {Size = UDim2.new(0, 100, 0, 100)}):Play()

local char = LocalPlayer.Character
local backpack = LocalPlayer:FindFirstChild("Backpack")
local gun = backpack and backpack:FindFirstChild("Gun") or char and char:FindFirstChild("Gun")
if not gun then return end

if not isPlayerAlive(LocalPlayer) then return end

local humanoid = char:FindFirstChildOfClass("Humanoid")
if not humanoid then return end

humanoid:EquipTool(gun)
task.wait(0.1)

if not isPlayerAlive(LocalPlayer) then return end

if shootMode == "Prever Murder" then
local targetMurderer = findNearestMurderer()
if targetMurderer then
local predictedPos = predictMurdererPosition(targetMurderer)
if predictedPos then
pcall(function()
if isPlayerAlive(LocalPlayer) then
local gunRemote = workspace:WaitForChild(LocalPlayer.Name):WaitForChild("Gun")        
:WaitForChild("KnifeLocal"):WaitForChild("CreateBeam"):WaitForChild("RemoteFunction")        
gunRemote:InvokeServer(1, predictedPos, "AH2")
end
end)
return
end
end
else
for _, player in pairs(Players:GetPlayers()) do
if player ~= LocalPlayer and player.Character then
local hasKnife = player.Character:FindFirstChild("Knife") or (player.Backpack and player.Backpack:FindFirstChild("Knife"))
if hasKnife then
local root = player.Character:FindFirstChild("HumanoidRootPart")
if not root then continue end

local pos = root.Position
local vel = root.Velocity
local predicted = pos

if shootMode == "Curve" then
predicted = pos + vel * getPingTime()
elseif shootMode == "Static" then
predicted = pos
elseif shootMode == "Instantly" then
predicted = pos
if isPlayerAlive(LocalPlayer) then
char:FindFirstChildOfClass("Humanoid"):EquipTool(gun)
end
end

pcall(function()
if isPlayerAlive(LocalPlayer) then
local gunRemote = workspace:WaitForChild(LocalPlayer.Name):WaitForChild("Gun")        
:WaitForChild("KnifeLocal"):WaitForChild("CreateBeam"):WaitForChild("RemoteFunction")        
gunRemote:InvokeServer(1, predicted, "AH2")
end
end)        
break

end
end
end
end
end

-- Função Shoot Murder Teleport
local function shootMurderTeleport()
if not isPlayerAlive(LocalPlayer) then return end
if not hasGun() then return end

TweenService:Create(shootMurderButton, TweenInfo.new(0.1), {Size = UDim2.new(0, 120, 0, 45)}):Play()
task.wait(0.1)
TweenService:Create(shootMurderButton, TweenInfo.new(0.1), {Size = UDim2.new(0, 120, 0, 50)}):Play()

local char = LocalPlayer.Character
local myRoot = char:FindFirstChild("HumanoidRootPart")
if not myRoot then return end

local originalPosition = myRoot.CFrame

local targetMurderer = findNearestMurderer()
if not targetMurderer then 
Rayfield:Notify({
Title = "Murder não encontrado!",
Content = "Nenhum murder foi encontrado no servidor.",
Duration = 3
})
return 
end

local murdererRoot = targetMurderer.Character:FindFirstChild("HumanoidRootPart")
if not murdererRoot then return end

local backpack = LocalPlayer:FindFirstChild("Backpack")
local gun = backpack and backpack:FindFirstChild("Gun") or char and char:FindFirstChild("Gun")
if not gun then return end

local humanoid = char:FindFirstChildOfClass("Humanoid")
if not humanoid then return end

humanoid:EquipTool(gun)
task.wait(0.1)

local murdererLookDirection = murdererRoot.CFrame.LookVector
local behindPosition = murdererRoot.Position - (murdererLookDirection * 5)
local teleportCFrame = CFrame.new(behindPosition, murdererRoot.Position)

myRoot.CFrame = teleportCFrame
task.wait(0.1)

if not isPlayerAlive(LocalPlayer) then 
myRoot.CFrame = originalPosition
return 
end

local murdererPos = murdererRoot.Position
local murdererVel = murdererRoot.Velocity
local predicted = murdererPos

if shootMode == "Curve" then
predicted = murdererPos + murdererVel * getPingTime()
elseif shootMode == "Static" then
predicted = murdererPos
elseif shootMode == "Prever Murder" then
local predictedPos = predictMurdererPosition(targetMurderer)
if predictedPos then predicted = predictedPos end
elseif shootMode == "Instantly" then
predicted = murdererPos
end

pcall(function()
if isPlayerAlive(LocalPlayer) then
local gunRemote = workspace:WaitForChild(LocalPlayer.Name):WaitForChild("Gun")        
:WaitForChild("KnifeLocal"):WaitForChild("CreateBeam"):WaitForChild("RemoteFunction")        
gunRemote:InvokeServer(1, predicted, "AH2")
end
end)

task.wait(0.2)
if isPlayerAlive(LocalPlayer) then
myRoot.CFrame = originalPosition
end

Rayfield:Notify({
Title = "Shot Executed!",
Content = "Teleportou, atirou no murder e voltou!",
Duration = 2
})
end

-- Auto Shoot V2
local function autoShootV2()
if not isPlayerAlive(LocalPlayer) then return end
if not hasGun() then return end

local char = LocalPlayer.Character
local backpack = LocalPlayer:FindFirstChild("Backpack")
local gun = backpack and backpack:FindFirstChild("Gun") or char and char:FindFirstChild("Gun")
if not gun then return end

if shootMode == "Prever Murder" then
local targetMurderer = findNearestMurderer()
if targetMurderer and isMurdererVisible(targetMurderer.Character) then
if not isPlayerAlive(LocalPlayer) then return end

local humanoid = char:FindFirstChildOfClass("Humanoid")
if not humanoid then return end

humanoid:EquipTool(gun)
task.wait(0.1)

if not isPlayerAlive(LocalPlayer) then return end

local predictedPos = predictMurdererPosition(targetMurderer)
if predictedPos then
pcall(function()
if isPlayerAlive(LocalPlayer) then
local gunRemote = workspace:WaitForChild(LocalPlayer.Name):WaitForChild("Gun")        
:WaitForChild("KnifeLocal"):WaitForChild("CreateBeam"):WaitForChild("RemoteFunction")        
gunRemote:InvokeServer(1, predictedPos, "AH2")
end
end)
end
end
return
end

for _, player in pairs(Players:GetPlayers()) do
if player ~= LocalPlayer and isMurdererSheriff(player) and player.Character then
if not isMurdererOnGround(player.Character) then
continue
end

if isMurdererVisible(player.Character) then
local root = player.Character:FindFirstChild("HumanoidRootPart")
local head = player.Character:FindFirstChild("Head")
if root and head then
if not isPlayerAlive(LocalPlayer) then return end

local humanoid = char:FindFirstChildOfClass("Humanoid")
if not humanoid then return end

humanoid:EquipTool(gun)
task.wait(0.1)

if not isPlayerAlive(LocalPlayer) then return end

local pos = root.Position
local vel = root.Velocity
local predicted = pos

if isMurdererJumping(player.Character) then
predicted = head.Position + Vector3.new(0, 3, 0)
else
if shootMode == "Curve" then
predicted = pos + vel * getPingTime()
elseif shootMode == "Static" then
predicted = pos
end
end

pcall(function()
if isPlayerAlive(LocalPlayer) then
local gunRemote = workspace:WaitForChild(LocalPlayer.Name):WaitForChild("Gun")        
:WaitForChild("KnifeLocal"):WaitForChild("CreateBeam"):WaitForChild("RemoteFunction")        
gunRemote:InvokeServer(1, predicted, "AH2")
end
end)
break
end
end
end
end
end

button.MouseButton1Click:Connect(shoot)
shootMurderButton.MouseButton1Click:Connect(function()
pcall(shootMurderTeleport)
end)

-- Loops
task.spawn(function()
while true do
if autoShootEnabled and isPlayerAlive(LocalPlayer) then
pcall(shoot)
task.wait(0.5)
else
task.wait(1)
end
end
end)

task.spawn(function()
while true do
if autoShootV2Enabled and isPlayerAlive(LocalPlayer) then
pcall(autoShootV2)
task.wait(0.1)
else
task.wait(1)
end
end
end)

LocalPlayer.CharacterAdded:Connect(function(character)
task.wait(2)
end)

local TabAuto = Window:CreateTab("Auto", 4483362458)
local autofarmEnabled = false
local autoBringCoins = false
local walkSpeed = 60
local safeY = 5
local coinCount = 0

local maps = {
"ResearchFacility", "Factory", "Milbase", "Workplace", "Hotel", "Hotel2",
"House2", "Mansion2", "Office3", "Bank2", "BioLab"
}

TabAuto:CreateToggle({
Name = "Auto Farm Coins",
CurrentValue = false,
Flag = "AutoFarmCoins",
Callback = function(Value)
autofarmEnabled = Value
end,
})

TabAuto:CreateToggle({
Name = "Auto Bring Coins",
CurrentValue = false,
Flag = "AutoBringCoins",
Callback = function(Value)
autoBringCoins = Value
end,
})

local function getCurrentMap()
for _, name in ipairs(maps) do
local map = Workspace:FindFirstChild(name)
if map and map:FindFirstChild("CoinContainer") then
return map
end
end
return nil
end

local function getAllCoins(map)
local coins = {}
local container = map:FindFirstChild("CoinContainer")
if container then
for _, obj in pairs(container:GetDescendants()) do
if obj:IsA("BasePart") and obj.Name == "MainCoin" then
table.insert(coins, obj)
end
end
end
return coins
end

local function walkTo(position)
local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
if not hrp then return end

local distance = (position - hrp.Position).Magnitude
local direction = (position - hrp.Position).Unit
local endTime = tick() + (distance / walkSpeed)

while tick() < endTime and autofarmEnabled do
if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then break end
LocalPlayer.Character.HumanoidRootPart.Velocity = direction * walkSpeed
RunService.RenderStepped:Wait()
end

LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.zero

end

local function teleportToSafeSpot(map)
local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
if not root then return end
local part = map:FindFirstChild("Floor") or map:FindFirstChildWhichIsA("BasePart")
if part then
root.CFrame = part.CFrame + Vector3.new(0, 10, 0)
else
root.CFrame = CFrame.new(0, 10, 0)
end
end

RunService.Stepped:Connect(function()
if autofarmEnabled and LocalPlayer.Character then
for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
if part:IsA("BasePart") then
part.CanCollide = false
end
end
end
end)

task.spawn(function()
while true do
if autofarmEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
if humanoid and humanoid.Health <= 0 then
repeat task.wait(1) until LocalPlayer.Character:FindFirstChildOfClass("Humanoid") and LocalPlayer.Character:FindFirstChildOfClass("Humanoid").Health > 0
task.wait(2)
end

local map = getCurrentMap()
if map then
local hrp = LocalPlayer.Character.HumanoidRootPart

if autoBringCoins then
local coins = getAllCoins(map)
for _, coin in ipairs(coins) do
pcall(function()
if coin and coin:IsA("BasePart") then
coin.CFrame = hrp.CFrame + Vector3.new(0, 2, 0)
end
end)
end
end

if hrp.Position.Y < safeY then
teleportToSafeSpot(map)
task.wait(1)
end

if autofarmEnabled then        
	local coins = getAllCoins(map)        
	table.sort(coins, function(a, b)        
		return (a.Position - hrp.Position).Magnitude < (b.Position - hrp.Position).Magnitude        
	end)        

	for _, coin in ipairs(coins) do        
		if autofarmEnabled and coin and coin:IsDescendantOf(game) then        
			local distance = (coin.Position - hrp.Position).Magnitude        
			if distance <= 40 then        
				pcall(function()        
					walkTo(coin.Position + Vector3.new(0, 2.5, 0))        
					task.wait(0.15)        
					coinCount += 1        
				end)        
			end        
		end        
	end        
end

end

end
task.wait(0.3)

end

end)

local AutoGetGun = { Enabled = false, CollectDistance = 5000 }

local function isMurderer()
for _, t in pairs(LocalPlayer.Character:GetChildren()) do
if t:IsA("Tool") and t.Name == "Knife" then return true end
end
return false
end

local function getNearestGun()
local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
if not root then return end

local closest, dist = nil, AutoGetGun.CollectDistance
for _, item in ipairs(Workspace:GetDescendants()) do
if item.Name == "GunDrop" then
local success, pos = pcall(function() return item:GetPivot().Position end)
if success and (root.Position - pos).Magnitude < dist then
closest = item
dist = (root.Position - pos).Magnitude
end
end
end
return closest

end

local function autoGetGunLoop()
while AutoGetGun.Enabled do
if not isMurderer() then
local gun = getNearestGun()
local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
if gun and gun:IsA("BasePart") and root then
local original = root.CFrame
root.CFrame = CFrame.new(gun.Position + Vector3.new(0, 2, 0))
task.wait()
root.CFrame = original
end
end
task.wait(3)
end
end

TabAuto:CreateToggle({
Name = "Auto Get Gun",
CurrentValue = false,
Flag = "AutoGetGunToggle",
Callback = function(Value)
AutoGetGun.Enabled = Value
if Value then task.spawn(autoGetGunLoop) end
end,
})

local TabAntiLag = Window:CreateTab("AntiLag", 4483362458)

local antiLagSettings = {
{ Name = "Disable Global Shadows", Action = function() Lighting.GlobalShadows = false end },
{ Name = "Increase Fog Range", Action = function() Lighting.FogEnd = 1000000 end },
{ Name = "Reduce Brightness", Action = function() Lighting.Brightness = 0 end },
{ Name = "Lock Time of Day", Action = function() Lighting.ClockTime = 14 end },
{ Name = "Remove Particles", Action = function()
for _, v in pairs(Workspace:GetDescendants()) do
if v:IsA("ParticleEmitter") or v:IsA("Trail") or v:IsA("Fire") or v:IsA("Smoke") then
v.Enabled = false
end
end
end },
{ Name = "Disable Reflections", Action = function() Lighting.ReflectionIntensity = 0 end },
{ Name = "Disable Blur", Action = function()
local blur = Lighting:FindFirstChildOfClass("BlurEffect")
if blur then
blur.Enabled = false
end
end },
{ Name = "Disable Depth of Field", Action = function()
local dof = Lighting:FindFirstChildOfClass("DepthOfFieldEffect")
if dof then
dof.Enabled = false
end
end },
{ Name = "Disable Bloom", Action = function()
local bloom = Lighting:FindFirstChildOfClass("BloomEffect")
if bloom then
bloom.Enabled = false
end
end },
{ Name = "Remove Local Shadows", Action = function()
for _, part in pairs(Workspace:GetDescendants()) do
if part:IsA("BasePart") then
part.CastShadow = false
end
end
end },
{ Name = "Disable Terrain Effects", Action = function()
if Terrain then
Terrain.WaterWaveSize = 0
Terrain.WaterWaveSpeed = 0
Terrain.WaterReflectance = 0
Terrain.WaterTransparency = 0
end
end },
{ Name = "Remove Decals", Action = function()
for _, decal in pairs(Workspace:GetDescendants()) do
if decal:IsA("Decal") then
decal.Transparency = 1
end
end
end },
{ Name = "Disable Dynamic Lights", Action = function()
for _, light in pairs(Workspace:GetDescendants()) do
if light:IsA("PointLight") or light:IsA("SpotLight") or light:IsA("SurfaceLight") then
light.Enabled = false
end
end
end },
{ Name = "Mute Sounds", Action = function()
for _, sound in pairs(Workspace:GetDescendants()) do
if sound:IsA("Sound") then
sound.Volume = 0
end
end
end },
{ Name = "Remove Local Particle Effects", Action = function()
for _, particle in pairs(LocalPlayer.Character:GetDescendants()) do
if particle:IsA("ParticleEmitter") or particle:IsA("Trail") then
particle.Enabled = false
end
end
end },
}

local toggles = {}

for i, setting in ipairs(antiLagSettings) do
toggles[i] = TabAntiLag:CreateToggle({
Name = setting.Name,
CurrentValue = false,
Callback = function(value)
if value then
setting.Action()
else
-- You can implement a revert action here if needed
end
end
})
end

-- Reapply enabled optimizations every 10 seconds
task.spawn(function()
while true do
for i, toggle in pairs(toggles) do
if toggle and toggle:Get() then
antiLagSettings[i].Action()
end
end
task.wait(10)
end
end)

local TabMurderer = Window:CreateTab("Murderer", 4483362458)
local autoKillAllEnabled = false
local fakeThrowing = false
local fovRadius = 150
local fovCircle = nil
local killButton = nil
local killButtonGui = nil

-- Função para verificar se sou o murder
local function isMurderer()
    local character = LocalPlayer.Character
    if not character then return false end
    
    -- Verifica se tem a faca no character
    local knife = character:FindFirstChild("Knife")
    if knife then return true end
    
    -- Verifica se tem a faca no backpack
    if LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChild("Knife") then
        return true
    end
    
    return false
end

-- Função para verificar se um player é válido para matar
local function isValidTarget(player)
    if player == LocalPlayer then return false end
    if not player.Character then return false end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return false end
    if not player.Character:FindFirstChild("HumanoidRootPart") then return false end
    return true
end

-- Função para matar um player
local function killPlayer(targetPlayer)
    if not isMurderer() then return end
    if not isValidTarget(targetPlayer) then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local knife = character:FindFirstChild("Knife") or (LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChild("Knife"))
    if not knife then return end
    
    -- Equipa a faca
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and knife.Parent == LocalPlayer.Backpack then
        humanoid:EquipTool(knife)
        task.wait(0.1)
    end
    
    -- Pega posição do target
    local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end
    
    -- Executa o kill
    pcall(function()
        knife:Activate()
        -- Teleporta momentaneamente para garantir o kill
        local myRoot = character:FindFirstChild("HumanoidRootPart")
        if myRoot then
            local originalPos = myRoot.CFrame
            myRoot.CFrame = targetRoot.CFrame
            task.wait(0.1)
            myRoot.CFrame = originalPos
        end
    end)
end

-- Toggle Auto Kill All
TabMurderer:CreateToggle({
    Name = "Auto Kill All (Murder Only)",
    CurrentValue = false,
    Flag = "AutoKillAllToggle",
    Callback = function(Value)
        autoKillAllEnabled = Value
    end,
})

-- Função para criar o círculo FOV
local function createFOVCircle()
    local screenGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
    screenGui.Name = "FOVCircle"
    screenGui.ResetOnSpawn = false
    
    local circle = Instance.new("Frame", screenGui)
    circle.Name = "Circle"
    circle.Size = UDim2.new(0, fovRadius * 2, 0, fovRadius * 2)
    circle.Position = UDim2.new(0.5, -fovRadius, 0.5, -fovRadius)
    circle.BackgroundTransparency = 1
    circle.BorderSizePixel = 0
    
    local circleCorner = Instance.new("UICorner", circle)
    circleCorner.CornerRadius = UDim.new(0.5, 0)
    
    local circleStroke = Instance.new("UIStroke", circle)
    circleStroke.Color = Color3.fromRGB(255, 0, 0)
    circleStroke.Thickness = 2
    circleStroke.Transparency = 0.3
    
    return screenGui, circle
end

-- Função para criar o botão Kill
local function createKillButton()
    local buttonGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
    buttonGui.Name = "KillButtonGui"
    buttonGui.ResetOnSpawn = false
    
    local button = Instance.new("TextButton", buttonGui)
    button.Size = UDim2.new(0, 100, 0, 100)
    button.Position = UDim2.new(0.5, -50, 0.6, 0)
    button.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
    button.TextColor3 = Color3.new(1, 1, 1)
    button.Font = Enum.Font.SourceSansBold
    button.TextSize = 14
    button.Text = "KILL"
    button.BorderSizePixel = 0
    
    local buttonCorner = Instance.new("UICorner", button)
    buttonCorner.CornerRadius = UDim.new(0.5, 0)
    
    -- Drag logic
    local dragging, dragStart, startPos, dragInput
    button.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = button.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    button.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            button.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
    
    return buttonGui, button
end

-- Função para encontrar player no FOV
local function getPlayerInFOV()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    
    local camera = workspace.CurrentCamera
    local myPosition = LocalPlayer.Character.HumanoidRootPart.Position
    
    for _, player in pairs(Players:GetPlayers()) do
        if isValidTarget(player) then
            local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
            if targetRoot then
                -- Converte posição 3D para 2D na tela
                local screenPoint, onScreen = camera:WorldToScreenPoint(targetRoot.Position)
                
                if onScreen then
                    -- Calcula distância do centro da tela
                    local screenCenter = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                    local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude
                    
                    -- Verifica se está dentro do FOV
                    if distance <= fovRadius then
                        return player
                    end
                end
            end
        end
    end
    
    return nil
end

-- Função para kill com teleport
local function killWithTeleport()
    if not isMurderer() then 
        Rayfield:Notify({
            Title = "Você não é o Murder!",
            Content = "Você precisa ser o assassino para usar esta função.",
            Duration = 3
        })
        return 
    end
    
    local targetPlayer = getPlayerInFOV()
    if not targetPlayer then
        Rayfield:Notify({
            Title = "Nenhum target no FOV!",
            Content = "Não há ninguém dentro do círculo FOV.",
            Duration = 2
        })
        return
    end
    
    local character = LocalPlayer.Character
    local myRoot = character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    -- Salva posição original
    local originalPosition = myRoot.CFrame
    
    -- Equipa a faca
    local knife = character:FindFirstChild("Knife") or (LocalPlayer.Backpack and LocalPlayer.Backpack:FindFirstChild("Knife"))
    if knife then
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid and knife.Parent == LocalPlayer.Backpack then
            humanoid:EquipTool(knife)
            task.wait(0.1)
        end
    end
    
    -- Teleporta para o target
    local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if targetRoot then
        myRoot.CFrame = targetRoot.CFrame
        task.wait(0.1)
        
        -- Executa o kill
        if knife then
            knife:Activate()
        end
        
        task.wait(0.2)
        
        -- Volta para posição original
        myRoot.CFrame = originalPosition
        
        Rayfield:Notify({
            Title = "Kill Executed!",
            Content = "Matou " .. targetPlayer.Name .. " e voltou!",
            Duration = 2
        })
    end
end

-- Slider para ajustar FOV
TabMurderer:CreateSlider({
    Name = "FOV Circle Size",
    Range = {50, 300},
    Increment = 10,
    Suffix = " pixels",
    CurrentValue = 150,
    Flag = "FOVSizeSlider",
    Callback = function(Value)
        fovRadius = Value
        -- Atualiza o círculo se existir
        if fovCircle then
            fovCircle.Size = UDim2.new(0, fovRadius * 2, 0, fovRadius * 2)
            fovCircle.Position = UDim2.new(0.5, -fovRadius, 0.5, -fovRadius)
        end
    end,
})

-- Toggle Fake Throwing Knife
TabMurderer:CreateToggle({
    Name = "Fake Throwing Knife (FOV + Kill Button)",
    CurrentValue = false,
    Flag = "FakeThrowingToggle",
    Callback = function(Value)
        fakeThrowing = Value
        
        if Value then
            -- Cria círculo FOV e botão Kill
            local circleGui, circle = createFOVCircle()
            local buttonGui, button = createKillButton()
            
            fovCircle = circle
            killButton = button
            killButtonGui = buttonGui
            
            -- Conecta função do botão
            button.MouseButton1Click:Connect(function()
                pcall(killWithTeleport)
            end)
        else
            -- Remove círculo FOV e botão
            if LocalPlayer.PlayerGui:FindFirstChild("FOVCircle") then
                LocalPlayer.PlayerGui.FOVCircle:Destroy()
            end
            if LocalPlayer.PlayerGui:FindFirstChild("KillButtonGui") then
                LocalPlayer.PlayerGui.KillButtonGui:Destroy()
            end
            fovCircle = nil
            killButton = nil
            killButtonGui = nil
        end
    end,
})

-- Loop do Auto Kill All
task.spawn(function()
    while true do
        if autoKillAllEnabled and isMurderer() then
            for _, player in pairs(Players:GetPlayers()) do
                if isValidTarget(player) then
                    pcall(function()
                        killPlayer(player)
                    end)
                    task.wait(0.5) -- Pausa entre kills para parecer mais natural
                end
            end
        end
        task.wait(1) -- Verifica a cada segundo
    end
end)

-- Atualização do círculo FOV em tempo real
task.spawn(function()
    while true do
        if fakeThrowing and fovCircle then
            -- Atualiza a cor do círculo baseado se há target no FOV
            local targetInFOV = getPlayerInFOV()
            if targetInFOV then
                fovCircle.UIStroke.Color = Color3.fromRGB(0, 255, 0) -- Verde quando há target
            else
                fovCircle.UIStroke.Color = Color3.fromRGB(255, 0, 0) -- Vermelho quando não há target
            end
        end
        task.wait(0.1)
    end
end)

-- Cleanup quando o character respawna
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(2)
    -- Recriar elementos se necessário
    if fakeThrowing then
        -- Remove e recria para evitar bugs
        if LocalPlayer.PlayerGui:FindFirstChild("FOVCircle") then
            LocalPlayer.PlayerGui.FOVCircle:Destroy()
        end
        if LocalPlayer.PlayerGui:FindFirstChild("KillButtonGui") then
            LocalPlayer.PlayerGui.KillButtonGui:Destroy()
        end
        
        task.wait(0.5)
        
        -- Recria se ainda estiver ativo
        if fakeThrowing then
            local circleGui, circle = createFOVCircle()
            local buttonGui, button = createKillButton()
            
            fovCircle = circle
            killButton = button
            killButtonGui = buttonGui
            
            button.MouseButton1Click:Connect(function()
                pcall(killWithTeleport)
            end)
        end
    end
end)

local Tab = Window:CreateTab("troll", 4483362458)

-- MM2 Advanced Fling Script
-- Features: Fling Murder, Fling Sheriff, Auto Fling Murder

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local RootPart = Character:WaitForChild("HumanoidRootPart")

-- Control variables
local AutoFlingMurderEnabled = false
local FlingPower = 50000 -- Fling power
local DetectionRange = 100 -- Distance to detect players

-- Function to detect player role
local function getPlayerRole(player)
    if not player.Character then return "Unknown" end
    
    -- Check if has knife (Murder)
    local knife = player.Backpack:FindFirstChild("Knife") or 
                 (player.Character:FindFirstChild("Knife"))
    if knife then
        return "Murder"
    end
    
    -- Check if has gun (Sheriff)
    local gun = player.Backpack:FindFirstChild("Gun") or 
               (player.Character:FindFirstChild("Gun"))
    if gun then
        return "Sheriff"
    end
    
    return "Innocent"
end

-- Function to get Murder player
local function getMurderer()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and getPlayerRole(player) == "Murder" then
            return player
        end
    end
    return nil
end

-- Function to get Sheriff player
local function getSheriff()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and getPlayerRole(player) == "Sheriff" then
            return player
        end
    end
    return nil
end

-- Advanced fling function with visual effects
local function advancedFling(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then 
        return false, "Player not found"
    end
    
    local targetCharacter = targetPlayer.Character
    local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    
    if not targetRootPart then 
        return false, "HumanoidRootPart not found"
    end
    
    -- Calculate distance
    local distance = (RootPart.Position - targetRootPart.Position).Magnitude
    if distance > DetectionRange then
        return false, "Player too far away (Distance: " .. math.floor(distance) .. ")"
    end
    
    -- Save original position
    local originalPosition = RootPart.Position
    local originalCFrame = RootPart.CFrame
    
    -- Teleport near target
    RootPart.CFrame = targetRootPart.CFrame * CFrame.new(0, 0, -3)
    
    -- Apply fling
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000) * FlingPower
    bodyVelocity.Velocity = Vector3.new(0, FlingPower/1000, 0)
    bodyVelocity.Parent = RootPart
    
    -- Remove BodyVelocity after time
    game:GetService("Debris"):AddItem(bodyVelocity, 0.1)
    
    -- Visual effect
    local effect = Instance.new("Explosion")
    effect.Position = targetRootPart.Position
    effect.BlastRadius = 0
    effect.BlastPressure = 0
    effect.Parent = workspace
    
    -- Return to original position after 5 second delay
    wait(5)
    RootPart.CFrame = originalCFrame
    
    return true, "Fling executed successfully!"
end

-- Safe fling function (avoids detection)
local function safeFling(targetPlayer, attempts)
    attempts = attempts or 3
    
    for i = 1, attempts do
        local success, message = advancedFling(targetPlayer)
        if success then
            return true, message
        end
        wait(0.5) -- Delay between attempts
    end
    
    return false, "Failed after " .. attempts .. " attempts"
end

-- Notification system
local function notify(title, text, duration)
    duration = duration or 5
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = title;
        Text = text;
        Duration = duration;
    })
end

-- Fling Murder Button
local FlingMurderButton = Tab:CreateButton({
    Name = "🗡️ Fling Murder",
    Callback = function()
        local murderer = getMurderer()
        if murderer then
            notify("🎯 Target Identified", "Murder found: " .. murderer.Name, 3)
            
            local success, message = safeFling(murderer)
            if success then
                notify("✅ Success", "Murder " .. murderer.Name .. " has been eliminated!", 4)
            else
                notify("❌ Error", message, 4)
            end
        else
            notify("⚠️ Warning", "No Murder detected in the server", 3)
        end
    end,
})

-- Fling Sheriff Button
local FlingSheriffButton = Tab:CreateButton({
    Name = "🔫 Fling Sheriff",
    Callback = function()
        local sheriff = getSheriff()
        if sheriff then
            notify("🎯 Target Identified", "Sheriff found: " .. sheriff.Name, 3)
            
            local success, message = safeFling(sheriff)
            if success then
                notify("✅ Success", "Sheriff " .. sheriff.Name .. " has been eliminated!", 4)
            else
                notify("❌ Error", message, 4)
            end
        else
            notify("⚠️ Warning", "No Sheriff detected in the server", 3)
        end
    end,
})

-- Auto Fling Murder Toggle
local AutoFlingMurderToggle = Tab:CreateToggle({
    Name = "⚡ Auto Fling Murder",
    CurrentValue = false,
    Flag = "AutoFlingMurder",
    Callback = function(Value)
        AutoFlingMurderEnabled = Value
        
        if Value then
            notify("🔄 Auto Fling Enabled", "Automatically searching for Murder...", 3)
        else
            notify("⏹️ Auto Fling Disabled", "Automatic system stopped", 2)
        end
    end,
})

-- Slider to adjust fling power
local FlingPowerSlider = Tab:CreateSlider({
    Name = "⚙️ Fling Power",
    Range = {10000, 100000},
    Increment = 5000,
    CurrentValue = FlingPower,
    Flag = "FlingPower",
    Callback = function(Value)
        FlingPower = Value
        notify("⚙️ Configuration", "Fling power adjusted to: " .. Value, 2)
    end,
})

-- Slider to adjust detection range
local DetectionRangeSlider = Tab:CreateSlider({
    Name = "📡 Detection Range",
    Range = {50, 300},
    Increment = 10,
    CurrentValue = DetectionRange,
    Flag = "DetectionRange",
    Callback = function(Value)
        DetectionRange = Value
        notify("📡 Configuration", "Range adjusted to: " .. Value .. " studs", 2)
    end,
})

-- Auto Fling System
spawn(function()
    while true do
        wait(2) -- Check every 2 seconds
        
        if AutoFlingMurderEnabled then
            local murderer = getMurderer()
            
            if murderer then
                -- Check if murder is nearby
                if murderer.Character and murderer.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = (RootPart.Position - murderer.Character.HumanoidRootPart.Position).Magnitude
                    
                    if distance <= DetectionRange then
                        local success, message = safeFling(murderer, 1) -- Only 1 attempt in auto mode
                        
                        if success then
                            notify("🎯 Auto Fling", "Murder " .. murderer.Name .. " eliminated automatically!", 3)
                        end
                    end
                end
            end
        end
    end
end)

-- System information
local InfoLabel = Tab:CreateLabel("📊 MM2 Advanced System v2.0")
local StatusLabel = Tab:CreateLabel("🟢 Status: Operational")

-- Real-time status update
spawn(function()
    while true do
        wait(5)
        
        local murderer = getMurderer()
        local sheriff = getSheriff()
        local murderStatus = murderer and ("Murder: " .. murderer.Name) or "Murder: Not detected"
        local sheriffStatus = sheriff and ("Sheriff: " .. sheriff.Name) or "Sheriff: Not detected"
        
        StatusLabel:Set("🔍 " .. murderStatus .. " | " .. sheriffStatus)
    end
end)

-- Security system - detects if being watched
local function isBeingWatched()
    local myPosition = RootPart.Position
    local watcherCount = 0
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local theirRoot = player.Character:FindFirstChild("HumanoidRootPart")
            if theirRoot then
                local distance = (myPosition - theirRoot.Position).Magnitude
                if distance < 50 then -- If someone is too close
                    watcherCount = watcherCount + 1
                end
            end
        end
    end
    
    return watcherCount > 2 -- If more than 2 people are nearby
end

-- Emergency button
local EmergencyButton = Tab:CreateButton({
    Name = "🚨 Emergency Stop",
    Callback = function()
        AutoFlingMurderEnabled = false
        AutoFlingMurderToggle:Set(false)
        
        notify("🚨 EMERGENCY", "All systems have been stopped!", 5)
    end,
})

-- Initialization message
notify("🚀 MM2 Advanced", "Script loaded successfully! All functions active.", 5)

print("=== MM2 Advanced Fling Script v2.0 ===")
print("✅ System initialized successfully!")
print("📋 Available features:")
print("   • Manual Fling Murder")
print("   • Manual Fling Sheriff") 
print("   • Auto Fling Murder")
print("   • Advanced Detection System")
print("   • Customizable Settings")
print("===========================================")

local Tab = Window:CreateTab("steal", 4483362458)

-- Advanced Auto Steal Gun System
local Toggle = Tab:CreateToggle({
    Name = "auto steal gun",
    CurrentValue = false,
    Flag = "AdvancedAutoStealGun",
    Callback = function(Value)
        getgenv().AdvancedAutoStealGun = Value
        
        if Value then
            -- Services
            local Players = game:GetService("Players")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local RunService = game:GetService("RunService")
            local TweenService = game:GetService("TweenService")
            local UserInputService = game:GetService("UserInputService")
            local Debris = game:GetService("Debris")
            
            local LocalPlayer = Players.LocalPlayer
            
            -- Configurações avançadas
            local Config = {
                FlingPower = 75,
                FlingDelay = 0.3,
                RespawnDelay = 1.2,
                AutoPickupGun = true,
                SmartFling = true,
                AntiDetection = true,
                NotifyActions = true,
                FlingDirection = "Random", -- "Up", "Random", "Towards"
                MinPlayersToFling = 2,
                BlacklistedPlayers = {},
                OnlyFlingIfMurdererNear = true,
                MurdererDetectionRange = 50
            }
            
            -- Estado do sistema
            local SystemState = {
                LastRole = "Innocent",
                HasGunBeforeDeath = false,
                DeathPosition = nil,
                FlingCount = 0,
                LastFlingTime = 0,
                MurdererPlayer = nil,
                IsInCooldown = false
            }
            
            -- Funções utilitárias
            local function createNotification(title, text, duration)
                if not Config.NotifyActions then return end
                -- Aqui você pode integrar com seu sistema de notificação
                print("[Auto Steal Gun] " .. title .. ": " .. text)
            end
            
            local function getMurderer()
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character then
                        local backpack = player:FindFirstChild("Backpack")
                        local character = player.Character
                        
                        -- Verifica se tem knife
                        if backpack and backpack:FindFirstChild("Knife") then
                            return player
                        end
                        
                        if character:FindFirstChildOfClass("Tool") then
                            local tool = character:FindFirstChildOfClass("Tool")
                            if tool.Name == "Knife" then
                                return player
                            end
                        end
                    end
                end
                return nil
            end
            
            local function getSheriff()
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and hasGun(player) then
                        return player
                    end
                end
                return nil
            end
            
            local function hasGun(player)
                if not player or not player.Character then return false end
                
                local character = player.Character
                local backpack = player:FindFirstChild("Backpack")
                
                -- Lista de armas possíveis
                local gunNames = {"Gun", "Revolver", "Laser", "Sheriff"}
                
                -- Verifica na mão
                local tool = character:FindFirstChildOfClass("Tool")
                if tool then
                    for _, gunName in pairs(gunNames) do
                        if tool.Name:lower():find(gunName:lower()) then
                            return true, tool
                        end
                    end
                end
                
                -- Verifica no backpack
                if backpack then
                    for _, item in pairs(backpack:GetChildren()) do
                        if item:IsA("Tool") then
                            for _, gunName in pairs(gunNames) do
                                if item.Name:lower():find(gunName:lower()) then
                                    return true, item
                                end
                            end
                        end
                    end
                end
                
                return false, nil
            end
            
            local function getOptimalFlingDirection()
                local character = LocalPlayer.Character
                if not character or not character:FindFirstChild("HumanoidRootPart") then
                    return Vector3.new(0, 50, 0)
                end
                
                local hrp = character.HumanoidRootPart
                local murderer = getMurderer()
                
                if Config.FlingDirection == "Random" then
                    local randomX = math.random(-30, 30)
                    local randomZ = math.random(-30, 30)
                    return Vector3.new(randomX, Config.FlingPower, randomZ)
                    
                elseif Config.FlingDirection == "Towards" and murderer and murderer.Character then
                    local murdererPos = murderer.Character.HumanoidRootPart.Position
                    local direction = (murdererPos - hrp.Position).Unit
                    return direction * Config.FlingPower + Vector3.new(0, 20, 0)
                    
                else -- "Up"
                    return Vector3.new(0, Config.FlingPower, 0)
                end
            end
            
            local function isMurdererNearby()
                if not Config.OnlyFlingIfMurdererNear then return true end
                
                local murderer = getMurderer()
                if not murderer or not murderer.Character then return false end
                
                local character = LocalPlayer.Character
                if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
                
                local distance = (murderer.Character.HumanoidRootPart.Position - 
                                character.HumanoidRootPart.Position).Magnitude
                
                return distance <= Config.MurdererDetectionRange
            end
            
            local function shouldFling()
                -- Verificações básicas
                if SystemState.IsInCooldown then return false end
                if #Players:GetPlayers() < Config.MinPlayersToFling then return false end
                if not hasGun(LocalPlayer) then return false end
                
                -- Verifica se murderer está próximo (se configurado)
                if not isMurdererNearby() then return false end
                
                -- Verifica cooldown de fling
                if tick() - SystemState.LastFlingTime < 3 then return false end
                
                -- Verifica se havia arma antes de morrer
                return SystemState.HasGunBeforeDeath
            end
            
            local function performAdvancedFling()
                local character = LocalPlayer.Character
                if not character or not character:FindFirstChild("HumanoidRootPart") then return end
                
                local humanoidRootPart = character.HumanoidRootPart
                local humanoid = character:FindFirstChild("Humanoid")
                
                -- Anti-detecção: randomiza ligeiramente o timing
                if Config.AntiDetection then
                    local randomDelay = math.random(1, 5) / 10
                    wait(randomDelay)
                end
                
                -- Salva posição de morte para possível recuperação
                SystemState.DeathPosition = humanoidRootPart.Position
                
                -- Cria efeito visual sutil (opcional)
                local flingDirection = getOptimalFlingDirection()
                
                -- Múltiplos métodos de fling para maior efetividade
                local methods = {}
                
                -- Método 1: BodyVelocity
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.MaxForce = Vector3.new(4000, 4000, 4000)
                bodyVelocity.Velocity = flingDirection
                bodyVelocity.Parent = humanoidRootPart
                table.insert(methods, bodyVelocity)
                
                -- Método 2: BodyPosition (backup)
                local bodyPosition = Instance.new("BodyPosition")
                bodyPosition.MaxForce = Vector3.new(4000, 0, 4000)
                bodyPosition.Position = humanoidRootPart.Position + Vector3.new(0, 20, 0)
                bodyPosition.Parent = humanoidRootPart
                table.insert(methods, bodyPosition)
                
                -- Método 3: Impulso via Humanoid
                if humanoid then
                    humanoid.PlatformStand = true
                end
                
                -- Atualiza estatísticas
                SystemState.FlingCount = SystemState.FlingCount + 1
                SystemState.LastFlingTime = tick()
                SystemState.IsInCooldown = true
                
                createNotification("Fling Executed", 
                    "Auto fling activated! Count: " .. SystemState.FlingCount, 3)
                
                -- Limpeza após delay
                spawn(function()
                    wait(Config.FlingDelay)
                    for _, method in pairs(methods) do
                        if method and method.Parent then
                            method:Destroy()
                        end
                    end
                    
                    if humanoid then
                        humanoid.PlatformStand = false
                    end
                    
                    -- Desativa o toggle
                    getgenv().AdvancedAutoStealGun = false
                    Toggle:Set(false)
                    
                    -- Cooldown de segurança
                    wait(2)
                    SystemState.IsInCooldown = false
                    
                    createNotification("System Reset", "Ready for next activation", 2)
                end)
            end
            
            local function tryPickupGun()
                if not Config.AutoPickupGun then return end
                
                wait(0.5) -- Espera objetos carregarem
                
                -- Procura por armas no chão próximas
                for _, obj in pairs(workspace:GetDescendants()) do
                    if obj:IsA("Tool") and obj.Parent == workspace then
                        local gunNames = {"Gun", "Revolver", "Laser"}
                        for _, gunName in pairs(gunNames) do
                            if obj.Name:lower():find(gunName:lower()) then
                                local character = LocalPlayer.Character
                                if character and character:FindFirstChild("HumanoidRootPart") then
                                    local distance = (obj.Handle.Position - 
                                                    character.HumanoidRootPart.Position).Magnitude
                                    
                                    if distance <= 20 then
                                        -- Tenta pegar a arma
                                        local humanoid = character:FindFirstChild("Humanoid")
                                        if humanoid then
                                            obj.Parent = LocalPlayer.Backpack
                                            createNotification("Gun Picked Up", 
                                                "Found and picked up: " .. obj.Name, 3)
                                            return true
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                return false
            end
            
            -- Evento principal de morte
            local deathConnection
            deathConnection = LocalPlayer.CharacterAdded:Connect(function(character)
                local humanoid = character:WaitForChild("Humanoid")
                local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
                
                -- Monitora papel atual
                spawn(function()
                    while character.Parent and getgenv().AdvancedAutoStealGun do
                        local hadGun, gunTool = hasGun(LocalPlayer)
                        if hadGun then
                            SystemState.LastRole = "Sheriff"
                        end
                        wait(1)
                    end
                end)
                
                humanoid.Died:Connect(function()
                    if not getgenv().AdvancedAutoStealGun then return end
                    
                    -- Registra se tinha arma ao morrer
                    SystemState.HasGunBeforeDeath = hasGun(LocalPlayer)
                    
                    if SystemState.HasGunBeforeDeath then
                        createNotification("Death Detected", 
                            "Died with gun! Preparing auto-fling on respawn...", 3)
                        
                        -- Aguarda respawn e executa lógica
                        LocalPlayer.CharacterAdded:Wait()
                        wait(Config.RespawnDelay)
                        
                        -- Tenta pegar arma automaticamente
                        local pickedUp = tryPickupGun()
                        
                        -- Executa fling se todas condições forem atendidas
                        if shouldFling() then
                            wait(0.5) -- Delay adicional para estabilidade
                            performAdvancedFling()
                        else
                            createNotification("Fling Skipped", 
                                "Conditions not met for auto-fling", 2)
                        end
                    end
                end)
            end)
            
            -- Sistema de monitoramento contínuo
            local monitorConnection
            monitorConnection = RunService.Heartbeat:Connect(function()
                if not getgenv().AdvancedAutoStealGun then return end
                
                -- Atualiza informações do murderer
                SystemState.MurdererPlayer = getMurderer()
                
                -- Verifica mudanças de papel
                local currentlyHasGun = hasGun(LocalPlayer)
                if currentlyHasGun and SystemState.LastRole ~= "Sheriff" then
                    SystemState.LastRole = "Sheriff"
                    createNotification("Role Change", "You are now the Sheriff!", 2)
                end
            end)
            
            -- Salva conexões para limpeza
            getgenv().AdvancedAutoStealConnections = {
                deathConnection = deathConnection,
                monitorConnection = monitorConnection
            }
            
            createNotification("System Activated", 
                "Advanced Auto Steal Gun is now active!", 3)
            
        else
            -- Limpeza ao desativar
            if getgenv().AdvancedAutoStealConnections then
                for name, connection in pairs(getgenv().AdvancedAutoStealConnections) do
                    if connection then
                        connection:Disconnect()
                    end
                end
                getgenv().AdvancedAutoStealConnections = nil
            end
            
            createNotification("System Deactivated", 
                "Advanced Auto Steal Gun has been disabled", 2)
        end
    end,
})

-- Toggle de configuração rápida
local ConfigToggle = Tab:CreateToggle({
    Name = "🔧 Smart Fling Mode",
    CurrentValue = true,
    Flag = "SmartFlingMode",
    Callback = function(Value)
        if getgenv().AdvancedAutoStealGun then
            -- Atualiza configurações em tempo real
            Config.SmartFling = Value
            Config.OnlyFlingIfMurdererNear = Value
            Config.AntiDetection = Value
            
            createNotification("Config Updated", 
                "Smart fling mode " .. (Value and "enabled" or "disabled"), 2)
        end
    end,
})

local Tab = Window:CreateTab("Settings", 4483362458)

-- Variables
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local RootPart = Character:WaitForChild("HumanoidRootPart")

local tpwalkEnabled = false
local jumpToggleEnabled = false
local connection
local jumpConnection
local landConnection
local wasJumping = false

-- Function to enable/disable TPWalk
local function toggleTPWalk(state)
    if state then
        if not connection then
            connection = RunService.Heartbeat:Connect(function()
                if tpwalkEnabled and RootPart and Humanoid then
                    local moveVector = Humanoid.MoveDirection
                    if moveVector.Magnitude > 0 then
                        -- TPWalk 2x faster
                        RootPart.CFrame = RootPart.CFrame + moveVector * (Humanoid.WalkSpeed / 16) * 0.5
                    end
                end
            end)
        end
        tpwalkEnabled = true
    else
        tpwalkEnabled = false
        if connection then
            connection:Disconnect()
            connection = nil
        end
    end
end

-- Function to detect jump and landing
local function setupJumpDetection()
    if jumpConnection then jumpConnection:Disconnect() end
    if landConnection then landConnection:Disconnect() end
    
    -- Detects when jumping
    jumpConnection = RunService.Heartbeat:Connect(function()
        if jumpToggleEnabled and Humanoid and RootPart then
            local isJumping = Humanoid:GetState() == Enum.HumanoidStateType.Freefall or 
                            Humanoid:GetState() == Enum.HumanoidStateType.Jumping or
                            Humanoid:GetState() == Enum.HumanoidStateType.Flying
            
            -- If started jumping, activate TPWalk
            if isJumping and not wasJumping then
                toggleTPWalk(true)
                wasJumping = true
            end
            
            -- If stopped jumping (touched ground), deactivate TPWalk
            if not isJumping and wasJumping then
                toggleTPWalk(false)
                wasJumping = false
            end
        end
    end)
end

-- Reconfigure when character respawns
LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    RootPart = Character:WaitForChild("HumanoidRootPart")
    wasJumping = false
    
    if jumpToggleEnabled then
        setupJumpDetection()
    end
end)

-- Main toggle
local Toggle = Tab:CreateToggle({
   Name = "2x speed glitch",
   CurrentValue = false,
   Flag = "TPWalkJumpToggle",
   Callback = function(Value)
        jumpToggleEnabled = Value
        
        if Value then
            setupJumpDetection()
            Rayfield:Notify({
                Title = "2x speed glitch activated",
                Content = "Jump to activate 2x TPWalk!",
                Duration = 3,
                Image = 4483362458
            })
        else
            -- Clear all connections
            if jumpConnection then jumpConnection:Disconnect() end
            if landConnection then landConnection:Disconnect() end
            toggleTPWalk(false)
            wasJumping = false
            
            Rayfield:Notify({
                Title = "2x speed glitch disabled",
                Content = "System turned off",
                Duration = 3,
                Image = 4483362458
            })
        end
   end,
})
